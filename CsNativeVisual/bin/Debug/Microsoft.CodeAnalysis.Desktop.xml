<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.Desktop</name>
    </assembly>
    <members>
        <member name="T:Microsoft.CodeAnalysis.AdditionalTextFile">
            <summary>
            Represents a non source code file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AdditionalTextFile.Path">
            <summary>
            Path to the file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdditionalTextFile.GetText(System.Threading.CancellationToken)">
            <summary>
            Returns a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> with the contents of this file, or <c>null</c> if
            there were errors reading the file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AdditionalTextFile.Diagnostics">
            <summary>
            Errors encountered when trying to read the additional file. Always empty if
            <see cref="M:Microsoft.CodeAnalysis.AdditionalTextFile.GetText(System.Threading.CancellationToken)"/> has not been called.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference">
            <summary>
            Represents analyzers stored in an analyzer assembly file.
            </summary>
            <remarks>
            Analyzer are read from the file, owned by the reference, and doesn't change 
            since the reference is accessed until the reference object is garbage collected.
            During this time the file is open and its content is read-only.
            
            If you need to manage the lifetime of the anayzer reference (and the file stream) explicitly use <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerImageReference"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.InMemoryAssemblyLoader">
            <summary>
            Handles loading assemblies without locking the corresponding DLL on disk.
            
            This is achieved by copying the DLL into a byte array, and then calling
            <see cref="M:System.Reflection.Assembly.Load(System.Byte[])"/> to load the assembly from the byte array.
            
            Does not handle multi-module assemblies.
            </summary>
            
            <remarks>
            The interesting bit is that <see cref="T:System.Reflection.Assembly"/> objects loaded in this way
            are not placed in the Load or Load-From binding contexts. If one of these
            needs a dependency to be resolved and it isn't already loaded or available in
            the GAC, the runtime will not do any probing to find it. Since it doesn't know
            where the assembly came from, it doesn't assume it knows how to resolve its
            dependencies.
            
            This means we also need to hook the <see cref="E:System.AppDomain.AssemblyResolve"/>
            event and handle finding and loading dependencies ourselves. We also need to
            handle loading the dependencies' dependencies, and so on.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.InMemoryAssemblyLoader.s_assembliesFromFiles">
            <summary>
            Maps from a full path to a file to a corresponding <see cref="T:System.Reflection.Assembly"/>
            that we've already loaded.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.InMemoryAssemblyLoader.s_filesFromAssemblyNames">
            <summary>
            Maps from an assembly full name to the directory where we found the
            corresponding file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.InMemoryAssemblyLoader.s_assembliesFromNames">
            <summary>
            Maps from an assembly full name to the corresponding <see cref="T:System.Reflection.Assembly"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.InMemoryAssemblyLoader.s_requestingFilesFromFiles">
            <summary>
            Maps from the full path to an assembly to the full path of the assembly
            that requested it.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.InMemoryAssemblyLoader.s_guard">
            <summary>
            Controls access to the loader's data structures.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.InMemoryAssemblyLoader.Load(System.String)">
            <summary>
            Loads the <see cref="T:System.Reflection.Assembly"/> at the given path without locking the file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.InMemoryAssemblyLoader.LoadCore(System.String)">
            <summary>
            Performs the actual loading of the assembly, updates data structures, and
            fires the <see cref="E:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.AssemblyLoad"/> event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.InMemoryAssemblyLoader.CurrentDomain_AssemblyResolve(System.Object,System.ResolveEventArgs)">
            <summary>
            Handles the <see cref="E:System.AppDomain.AssemblyResolve"/> event.
            </summary>
            <remarks>
            This handler catches and swallow any and all exceptions that
            arise, and simply returns null when they do. Leaking an exception
            from the event handler may interrupt the entire assembly
            resolution process, which is undesirable.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.InMemoryAssemblyLoader.ResolveForUnknownRequestor(System.String)">
            <summary>
            Attempts to find and load an <see cref="T:System.Reflection.Assembly"/> when the requesting <see cref="T:System.Reflection.Assembly"/>
            is unknown.
            </summary>
            <remarks>
            In this case we simply look next to all the assemblies we have previously loaded for one with the
            correct name and a matching <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentity"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.InMemoryAssemblyLoader.ResolveForKnownRequestor(System.String,System.Reflection.Assembly)">
            <summary>
            Attempts to find and load an <see cref="T:System.Reflection.Assembly"/> when the requesting <see cref="T:System.Reflection.Assembly"/>
            is known.
            </summary>
            <remarks>
            This method differs from <see cref="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.InMemoryAssemblyLoader.ResolveForUnknownRequestor(System.String)"/> in a couple of ways.
            First, we only attempt to handle the load if the requesting assembly is one we've loaded.
            If it isn't one of ours, then presumably some other component is hooking <see cref="E:System.AppDomain.AssemblyResolve"/>
            and will have a better idea of how to load the assembly.
            Second, we only look immediately next to the requesting assembly, instead of next to all the assemblies
            we've previously loaded. An analyzer needs to ship with all of its dependencies, and if it doesn't we don't
            want to mask the problem.
            </remarks>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.AssemblyLoad">
            <summary>
            Fired when an <see cref="T:System.Reflection.Assembly"/> referred to by an <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference"/>
            (or a dependent <see cref="T:System.Reflection.Assembly"/>) is loaded.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.TryGetRequestingAssemblyPath(System.String)">
            <summary>
            Maps from one assembly back to the assembly that requested it, if known.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.#ctor(System.String,System.Func{System.String,System.Reflection.Assembly})">
            <summary>
            Creates an AnalyzerFileReference with the given <paramref name="fullPath"/>.
            </summary>
            <param name="fullPath">Full path of the analyzer assembly.</param>
            <param name="getAssembly">An optional assembly loader to override the default assembly load mechanism.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.AddAnalyzers(System.Collections.Immutable.ImmutableDictionary{System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer}}.Builder)">
            <summary>
            Adds the <see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/> of <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> 
            for all languages defined in this assembly reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.AddAnalyzers(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer}.Builder,System.String)">
            <summary>
            Adds the <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> defined in this assembly reference of given <paramref name="language"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.GetAnalyzerTypeNameMap(System.String)">
            <summary>
            Opens the analyzer dll with the metadata reader and builds a map of language -> analyzer type names.
            </summary>
            <exception cref="T:System.BadImageFormatException">The PE image format is invalid.</exception>
            <exception cref="T:System.IO.IOException">IO error reading the metadata.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeAnalysisDesktopResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisDesktopResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisDesktopResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisDesktopResources.KeepAliveIsNotAnInteger">
            <summary>
              Looks up a localized string similar to Argument to &apos;/keepalive&apos; option is not a 32-bit integer..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisDesktopResources.KeepAliveIsTooSmall">
            <summary>
              Looks up a localized string similar to Arguments to &apos;/keepalive&apos; option below -1 are invalid..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisDesktopResources.KeepAliveWithoutShared">
            <summary>
              Looks up a localized string similar to &apos;/keepalive&apos; option is only valid with &apos;/shared&apos; option..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisDesktopResources.MismatchedVersion">
            <summary>
              Looks up a localized string similar to Roslyn compiler server reports different protocol version than build task..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisDesktopResources.MissingKeepAlive">
            <summary>
              Looks up a localized string similar to Missing argument for &apos;/keepalive&apos; option..
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentityExtensions.ToAssemblyName(Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Converts this identity to <see cref="T:System.Reflection.AssemblyName"/>.
            </summary>
            <returns>A new instance of <see cref="T:System.Reflection.AssemblyName"/>.</returns>
            <exception cref="T:System.Globalization.CultureNotFoundException">The culture specified in <see cref="P:Microsoft.CodeAnalysis.AssemblyIdentity.CultureName"/> is not available on the current platform.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AssemblyPortabilityPolicy">
            <summary>
            Policy to be used when matching assembly reference to an assembly definition accross platforms.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyVersion.op_Explicit(System.Version)~Microsoft.CodeAnalysis.AssemblyVersion">
            <summary>
            Converts <see cref="T:System.Version"/> to <see cref="T:Microsoft.CodeAnalysis.AssemblyVersion"/>.
            </summary>
            <exception cref="T:System.InvalidCastException">Major, minor, build or revision number are less than 0 or greater than 0xFFFF.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommandLineReference">
            <summary>
            Describes a command line metadata reference (assembly or netmodule) specification.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineReference.Reference">
            <summary>
            Metadata file path or an assembly display name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineReference.Properties">
            <summary>
            Metadata reference properties.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommandLineSourceFile">
            <summary>
            Describes a source file specification stored on command line arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineSourceFile.Path">
            <summary>
            Resolved absolute path of the source file (does not contain wildcards).
            </summary>
            <remarks>
            Although this path is absolute it may not be normalized. That is, it may contain ".." and "." in the middle. 
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineSourceFile.IsScript">
            <summary>
            True if the file should be treated as a script file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommandLineArguments">
            <summary>
            The base class for representing command line arguments to a
            <see cref="T:Microsoft.CodeAnalysis.CommonCompiler"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.BaseDirectory">
            <summary>
            Directory used to resolve relative paths stored in the arguments.
            </summary>
            <remarks>
            Except for paths stored in <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.MetadataReferences"/>, all
            paths stored in the properties of this class are resolved and
            absolute. This is the directory that relative paths specified on
            command line were resolved against.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.ReferencePaths">
            <summary>
            Sequence of absolute paths used to search for references.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.KeyFileSearchPaths">
            <summary>
            Sequence of absolute paths used to search for key files.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.Utf8Output">
            <summary>
            If true, use UTF8 for output.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.CompilationName">
            <summary>
            Compilation name or null if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.EmitOptions">
            <summary>
            Gets the emit options.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.OutputFileName">
            <summary>
            Name of the output file or null if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.PdbPath">
            <summary>
            Path of the PDB file or null if same as output binary path with .pdb extension.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.EmitPdb">
            <summary>
            True to emit PDB file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.OutputDirectory">
            <summary>
            Absolute path of the output directory.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.DocumentationPath">
            <summary>
            Absolute path of the documentation comment XML file or null if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.AppConfigPath">
            <summary>
            An absolute path of the App.config file or null if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.Errors">
            <summary>
            Errors while parsing the command line arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.MetadataReferences">
            <summary>
            References to metadata supplied on the command line. 
            Includes assemblies specified via /r and netmodules specified via /addmodule.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.AnalyzerReferences">
            <summary>
            References to analyzers supplied on the command line.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.AdditionalFiles">
            <summary>
            A set of additional non-code text files that can be used by analyzers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.DisplayLogo">
            <summary>
            If true, prepend the command line header logo during 
            <see cref="M:Microsoft.CodeAnalysis.CommonCompiler.Run(System.IO.TextWriter,System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.DisplayHelp">
            <summary>
            If true, append the command line help during
            <see cref="M:Microsoft.CodeAnalysis.CommonCompiler.Run(System.IO.TextWriter,System.Threading.CancellationToken)"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.Win32ResourceFile">
            <summary>
            The path to a Win32 resource.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.Win32Icon">
            <summary>
            The path to a .ico icon file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.Win32Manifest">
            <summary>
            The path to a Win32 manifest file to embed
            into the output portable executable (PE) file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.NoWin32Manifest">
            <summary>
            If true, do not embed any Win32 manifest, including
            one specified by <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.Win32Manifest"/> or any
            default manifest.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.ManifestResources">
            <summary>
            Resources specified as arguments to the compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.Encoding">
            <summary>
            Encoding to be used for source files or 'null' for autodetect/default.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.ChecksumAlgorithm">
            <summary>
            Hash algorithm to use to calculate source file debug checksums.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.ScriptArguments">
            <summary>
            Arguments following script argument separator "--" or null if <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.IsInteractive"/> is false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.SourceFiles">
            <summary>
            Source file paths.
            </summary>
            <remarks>
            Includes files specified directly on command line as well as files matching patterns specified 
            on command line using '*' and '?' wildcards or /recurse option.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.TouchedFilesPath">
            <summary>
            Full path of a log of file paths accessed by the compiler, or null if file logging should be suppressed.
            </summary>
            <remarks>
            Two log files will be created: 
            One with path <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.TouchedFilesPath"/> and extension ".read" logging the files read,
            and second with path <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.TouchedFilesPath"/> and extension ".write" logging the files written to during compilation.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.PrintFullPaths">
            <summary>
            If true, prints the full path of the file containing errors or
            warnings in diagnostics.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.ParseOptions">
            <summary>
            Options to the <see cref="T:Microsoft.CodeAnalysis.CommandLineParser"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.CompilationOptions">
            <summary>
            Options to the <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.PreferredUILang">
            <summary>
            Specify the preferred output language name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineArguments.ResolveMetadataReferences(Microsoft.CodeAnalysis.MetadataReferenceResolver)">
            <summary>
            Resolves metadata references stored in <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.MetadataReferences"/> using given file resolver and metadata provider.
            </summary>
            <param name="metadataResolver"><see cref="T:Microsoft.CodeAnalysis.MetadataFileReferenceResolver"/> to use for assembly name and relative path resolution.</param>
            <returns>Yields resolved metadata references or <see cref="T:Microsoft.CodeAnalysis.UnresolvedMetadataReference"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="metadataResolver"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineArguments.ResolveMetadataReferences(Microsoft.CodeAnalysis.MetadataReferenceResolver,System.Collections.Generic.List{Microsoft.CodeAnalysis.DiagnosticInfo},Microsoft.CodeAnalysis.CommonMessageProvider)">
            <summary>
            Resolves metadata references stored in <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.MetadataReferences"/> using given file resolver and metadata provider.
            If a non-null diagnostic bag <paramref name="diagnosticsOpt"/> is provided, it catches exceptions that may be generated while reading the metadata file and
            reports appropriate diagnostics.
            Otherwise, if <paramref name="diagnosticsOpt"/> is null, the exceptions are unhandled.
            </summary>
            <remarks>
            called by CommonCompiler with diagnostics and message provider
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineArguments.ResolveAnalyzerReferences">
            <summary>
            Resolves analyzer references stored in <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.AnalyzerReferences"/> using given file resolver.
            </summary>
            <returns>Yields resolved <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference"/> or <see cref="T:Microsoft.CodeAnalysis.Diagnostics.UnresolvedAnalyzerReference"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.EnumerateFiles(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Enumerates files in the specified directory and subdirectories whose name matches the given pattern.
            </summary>
            <param name="directory">Full path of the directory to enumerate.</param>
            <param name="fileNamePattern">File name pattern. May contain wildcards '*' (matches zero or more characters) and '?' (matches any character).</param>
            <param name="searchOption">Specifies whether to search the specified <paramref name="directory"/> only, or all its subdirectories as well.</param>
            <returns>Sequence of file paths.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.RemoveTrailingSpacesAndDots(System.String)">
            <summary>
            Trims all '.' and whitespaces from the end of the path
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.TryParseClientArgs(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.List{System.String}@,System.Boolean@,System.String@,System.String@)">
            <summary>
            Returns false if any of the client arguments are invalid and true otherwise.
            </summary>
            <param name="args">
            The original args to the client.
            </param>
            <param name="parsedArgs">
            The original args minus the client args, if no errors were encountered.
            </param>
            <param name="containsShared">
            Only defined if no errors were encountered.
            True if '/shared' was an argument, false otherwise.
            </param>
            <param name="keepAliveValue">
            Only defined if no errors were encountered.
            The value to the '/keepalive' argument if one was specified, null otherwise.
            </param>
            <param name="errorMessage">
            Only defined if errors were encountered.
            The error message for the encountered error.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.ParseResponseFile(System.String,System.Collections.Generic.IList{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Parse a response file into a set of arguments. Errors openening the response file are output into "errors".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.ParseResponseLines(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Take a string of lines from a response file, remove comments, 
            and split into a set of command line arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.RemoveAllQuotes(System.String)">
            <summary>
            Remove all double quote characters from the given string.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.SplitCommandLineIntoArguments(System.String,System.Boolean)">
            <summary>
            Split a command line by the same rules as Main would get the commands.
            </summary>
            <remarks>
            Rules for command line parsing, according to MSDN:
            
            Arguments are delimited by white space, which is either a space or a tab.
             
            A string surrounded by double quotation marks ("string") is interpreted 
            as a single argument, regardless of white space contained within. 
            A quoted string can be embedded in an argument.
             
            A double quotation mark preceded by a backslash (\") is interpreted as a 
            literal double quotation mark character (").
             
            Backslashes are interpreted literally, unless they immediately precede a 
            double quotation mark.
             
            If an even number of backslashes is followed by a double quotation mark, 
            one backslash is placed in the argv array for every pair of backslashes, 
            and the double quotation mark is interpreted as a string delimiter.
             
            If an odd number of backslashes is followed by a double quotation mark, 
            one backslash is placed in the argv array for every pair of backslashes, 
            and the double quotation mark is "escaped" by the remaining backslash, 
            causing a literal double quotation mark (") to be placed in argv.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.Split(System.String,System.Func{System.Char,System.Boolean})">
            <summary>
            Split a string, based on whether "splitHere" returned true on each character.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.CondenseDoubledBackslashes(System.String)">
            <summary>
            Condense double backslashes that precede a quotation mark to single backslashes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.AddBackslashes(System.Text.StringBuilder,System.Int32)">
            <summary>
            Add "count" backslashes to a StringBuilder. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.ParseSeparatedStrings(System.String,System.Char[],System.StringSplitOptions)">
            <summary>
            Split a string by a set of separators, taking quotes into account.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.TryParseUInt64(System.String,System.UInt64@)">
            <summary>
            Tries to parse a UInt64 from string in either decimal, octal or hex format.
            </summary>
            <param name="value">The string value.</param>
            <param name="result">The result if parsing was successful.</param>
            <returns>true if parsing was successful, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.TryParseUInt16(System.String,System.UInt16@)">
            <summary>
            Tries to parse a UInt16 from string in either decimal, octal or hex format.
            </summary>
            <param name="value">The string value.</param>
            <param name="result">The result if parsing was successful.</param>
            <returns>true if parsing was successful, otherwise false.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonCompiler">
            <summary>
            Base class for csc.exe, csi.exe, vbc.exe and vbi.exe implementations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.GetResponseFileDirectory">
            <summary>
            Return the path in which to look for response files.  This should only be called 
            on EXE entry points as the implementation relies on managed entry points.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.GetResponseFileFullPath(System.String)">
            <summary>
            Called from a compiler exe entry point to get the full path to the response file for
            the given name.  Will return a fully qualified path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.ResolveMetadataReferences(Microsoft.CodeAnalysis.MetadataFileReferenceResolver,Microsoft.CodeAnalysis.MetadataFileReferenceProvider,System.Collections.Generic.List{Microsoft.CodeAnalysis.DiagnosticInfo},Microsoft.CodeAnalysis.AssemblyIdentityComparer,Microsoft.CodeAnalysis.TouchedFileLogger,Microsoft.CodeAnalysis.MetadataFileReferenceResolver@)">
            <summary>
            Resolves metadata references stored in command line arguments and reports errors for those that can't be resolved.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.ReadFileContent(Microsoft.CodeAnalysis.CommandLineSourceFile,System.Collections.Generic.IList{Microsoft.CodeAnalysis.DiagnosticInfo},System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)">
            <summary>
            Reads content of a source file.
            </summary>
            <param name="file">Source file information.</param>
            <param name="diagnostics">Storage for diagnostics.</param>
            <param name="encoding">Encoding to use or 'null' for autodetect/default</param>
            <param name="checksumAlgorithm">Hash algorithm used to calculate file checksum.</param>
            <returns>File content or null on failure.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.ReadFileContent(Microsoft.CodeAnalysis.CommandLineSourceFile,System.Collections.Generic.IList{Microsoft.CodeAnalysis.DiagnosticInfo},System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.String@)">
            <summary>
            Reads content of a source file.
            </summary>
            <param name="file">Source file information.</param>
            <param name="diagnostics">Storage for diagnostics.</param>
            <param name="encoding">Encoding to use or 'null' for autodetect/default</param>
            <param name="checksumAlgorithm">Hash algorithm used to calculate file checksum.</param>
            <param name="normalizedFilePath">If given <paramref name="file"/> opens successfully, set to normalized absolute path of the file, null otherwise.</param>
            <returns>File content or null on failure.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.Run(System.IO.TextWriter,System.Threading.CancellationToken)">
            <summary>
            csc.exe and vbc.exe entry point.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.GetOutputFileName(Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Given a compilation and a destination directory, determine three names:
              1) The name with which the assembly should be output (default = null, which indicates that the compilation output name should be used).
              2) The path of the assembly/module file (default = destination directory + compilation output name).
              3) The path of the pdb file (default = assembly/module path with ".pdb" extension).
            </summary>
            <remarks>
            C# has a special implementation that implements idiosyncratic behavior of csc.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonCompiler.FileOpen">
            <summary>
            Test hook for intercepting File.Open.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.RunInteractive(System.IO.TextWriter)">
            <summary>
            csi.exe and vbi.exe entry point.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonCompiler.Culture">
            <summary>
              When overriden by a derived class, this property can override the current thread's
              CurrentUICulture property for diagnostic message resource lookups.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonCompiler.ExistingReferencesResolver">
            <summary>
            Looks for metadata references among the assembly file references given to the compilation when constructed.
            When scripts are included into a project we don't want #r's to reference other assemblies than those 
            specified explicitly in the project references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.ExistingReferencesResolver.ResolveAssemblyName(System.String)">
            <summary>
            When compiling to a file all unresolved assembly names have to match one of the file references specified on command line.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.ExistingReferencesResolver.ResolveMetadataFile(System.String,System.String)">
            <summary>
            When compiling to a file all relative paths have to match one of the file references specified on command line.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonCompiler.CompilerEmitStreamProvider">
            <summary>
            This implementation of <see cref="T:Microsoft.CodeAnalysis.Compilation.EmitStreamProvider"/> will delay the creation
            of the PE / PDB file until the compiler determines the compilation has succeeded.  This prevents
            the compiler from deleting output from the previous compilation when a new compilation 
            fails.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InvalidRuleSetException">
            <summary>
            Represents errors that occur while parsing RuleSet files.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RuleSet">
            <summary>
            Represents a set of rules as specified in a rulset file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuleSet.FilePath">
            <summary>
            The file path of the ruleset file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuleSet.GeneralDiagnosticOption">
            <summary>
            The global option specified by the IncludeAll tag.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuleSet.SpecificDiagnosticOptions">
            <summary>
            Individual ruleids and their associated actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuleSet.Includes">
            <summary>
            List of rulesets included by this ruleset.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.#ctor(System.String,Microsoft.CodeAnalysis.ReportDiagnostic,System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RuleSetInclude})">
            <summary>
            Create a RuleSet.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.WithEffectiveAction(Microsoft.CodeAnalysis.ReportDiagnostic)">
            <summary>
            Create a RuleSet with a global effective action applied on it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.GetEffectiveRuleSet(System.Collections.Generic.HashSet{System.String})">
            <summary>
            Get the effective ruleset after resolving all the included rulesets.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.GetEffectiveIncludes">
            <summary>
            Get all the files involved in resolving this ruleset.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.IsStricterThan(Microsoft.CodeAnalysis.ReportDiagnostic,Microsoft.CodeAnalysis.ReportDiagnostic)">
            <summary>
            Returns true if the action1 is stricter than action2.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.LoadEffectiveRuleSetFromFile(System.String)">
            <summary>
            Load the ruleset from the specified file. This ruleset will contain
            all the rules resolved from the includes specified in the ruleset file
            as well. See also: <seealso cref="M:Microsoft.CodeAnalysis.RuleSet.GetEffectiveIncludesFromFile(System.String)" />.
            </summary>
            <returns>
            A ruleset that contains resolved rules or null if there were errors.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.GetEffectiveIncludesFromFile(System.String)">
            <summary>
            Get the paths to all files contributing rules to the ruleset from the specified file.
            See also: <seealso cref="M:Microsoft.CodeAnalysis.RuleSet.LoadEffectiveRuleSetFromFile(System.String)" />.
            </summary>
            <returns>
            The full paths to included files, or an empty array if there were errors.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.GetDiagnosticOptionsFromRulesetFile(System.String,System.Collections.Generic.Dictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic}@)">
            <summary>
            Parses the ruleset file at the given <paramref name="rulesetFileFullPath"/> and returns the following diagnostic options from the parsed file:
            1) A map of <paramref name="specificDiagnosticOptions"/> from rule ID to <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> option.
            2) A global <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> option for all rules in the ruleset file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RuleSetInclude">
            <summary>
            Represents a Include tag in a RuleSet file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuleSetInclude.IncludePath">
            <summary>
            The path of the included file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuleSetInclude.Action">
            <summary>
            The effective action to apply on this included ruleset.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetInclude.#ctor(System.String,Microsoft.CodeAnalysis.ReportDiagnostic)">
            <summary>
            Create a RuleSetInclude given the includepath and the effective action.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetInclude.LoadRuleSet(Microsoft.CodeAnalysis.RuleSet)">
            <summary>
            Gets the RuleSet associated with this ruleset include
            </summary>
            <param name="parent">The parent of this ruleset include</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetInclude.GetIncludePath(Microsoft.CodeAnalysis.RuleSet)">
            <summary>
            Returns a full path to the include file. Relative paths are expanded relative to the current rule set file.
            </summary>
            <param name="parent">The parent of this rule set include</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RuleSetProcessor">
            <summary>
            This type is responsible for parsing a ruleset xml file and producing a <see cref="T:Microsoft.CodeAnalysis.RuleSet"/> object.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.CreateRuleSetSchema">
            <summary>
            Static constructor for initializing the schema object to be used for schema validation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.LoadFromFile(System.String)">
            <summary>
            Creates and loads the rule set from a file
            </summary>
            <param name="filePath">The file path to load the rule set</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadRuleSet(System.Xml.XmlNode,System.String)">
            <summary>
            Load the rule set from the XML node
            </summary>
            <param name="ruleSetNode">The rule set node from which to create a rule set object</param>
            <param name="filePath">The file path to the rule set file</param>
            <returns>A rule set object with data from the given XML node</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadRules(System.Xml.XmlNode)">
            <summary>
            Load the rules from the XML node
            </summary>
            <param name="rulesNode">The rules node from which to loop through each child rule node</param>
            <returns>A list of rule objects with data from the given XML node</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadRule(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Load the rule from the XML node
            </summary>
            <param name="ruleNode">The rule node from which to create a rule object</param>
            <param name="analyzer">The analyzer this rule belongs to</param>
            <param name="space">The namespace this rule belongs to</param>
            <returns>A rule object with data from the given XML node</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadRuleSetInclude(System.Xml.XmlNode)">
            <summary>
            Load the included rule set from the XML node
            </summary>
            <param name="includeNode">The include node from which to create a RuleSetInclude object</param>
            <returns>A RuleSetInclude object with data from the given XML node</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadAction(System.Xml.XmlNode)">
            <summary>
            Reads the action from the given node
            </summary>
            <param name="node">The node to read the action, it can be a rule node or an include node</param>
            <returns>The rule action</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadIncludeAll(System.Xml.XmlNode)">
            <summary>
            Load the IncludedAll from the XML node
            </summary>
            <param name="includeAllNode">The IncludeAll node from which to create a IncludeAll object</param>
            <returns>A IncludeAll object with data from the given XML node</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadNonEmptyAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            Reads an attribute from a node and validates that it is not empty.
            </summary>
            <param name="node">The XML node that contains the attribute</param>
            <param name="attributeName">The name of the attribute to read</param>
            <returns>The attribute value</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.GetDefaultXmlReaderSettings">
            <summary>
            Gets the default settings to read the ruleset xml file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TouchedFileLogger">
            <summary>
            Used for logging all the paths which are "touched" (used) in any way
            in the process of compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TouchedFileLogger.AddRead(System.String)">
            <summary>
            Adds a fully-qualified path to the Logger for a read file.
            Semantics are undefined after a call to <see cref="M:Microsoft.CodeAnalysis.TouchedFileLogger.WriteReadPaths(System.IO.TextWriter)" />.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TouchedFileLogger.AddWritten(System.String)">
            <summary>
            Adds a fully-qualified path to the Logger for a written file.
            Semantics are undefined after a call to <see cref="M:Microsoft.CodeAnalysis.TouchedFileLogger.WriteWrittenPaths(System.IO.TextWriter)" />.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TouchedFileLogger.AddReadWritten(System.String)">
            <summary>
            Adds a fully-qualified path to the Logger for a read and written
            file. Semantics are undefined after a call to
            <see cref="M:Microsoft.CodeAnalysis.TouchedFileLogger.WriteWrittenPaths(System.IO.TextWriter)" />.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TouchedFileLogger.WriteReadPaths(System.IO.TextWriter)">
            <summary>
            Writes all of the paths the TouchedFileLogger to the given 
            TextWriter in upper case. After calling this method the
            logger is in an undefined state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TouchedFileLogger.WriteWrittenPaths(System.IO.TextWriter)">
            <summary>
            Writes all of the paths the TouchedFileLogger to the given 
            TextWriter in upper case. After calling this method the
            logger is in an undefined state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileSystemExtensions.Emit(Microsoft.CodeAnalysis.Compilation,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},System.Threading.CancellationToken)">
            <summary>
            Emit the IL for the compilation into the specified stream.
            </summary>
            <param name="compilation">Compilation.</param>
            <param name="outputPath">Path of the file to which the compilation will be written.</param>
            <param name="pdbPath">Path of the file to which the compilation's debug info will be written.
            Also embedded in the output file.  Null to forego PDB generation.
            </param>
            <param name="xmlDocPath">Path of the file to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
            <param name="win32ResourcesPath">Path of the file from which the compilation's Win32 resources will be read (in RES format).  
            Null to indicate that there are none.</param>
            <param name="manifestResources">List of the compilation's managed resources.  Null to indicate that there are none.</param>
            <param name="cancellationToken">To cancel the emit process.</param>
            <exception cref="T:System.ArgumentNullException">Compilation or path is null.</exception>
            <exception cref="T:System.ArgumentException">Path is empty or invalid.</exception>
            <exception cref="T:System.IO.IOException">An error occurred while reading or writing a file.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopAssemblyIdentityComparer.#ctor(Microsoft.CodeAnalysis.AssemblyPortabilityPolicy)">
            <param name="policy">Assembly portability policy, usually provided through an app.config file.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopAssemblyIdentityComparer.LoadFromXml(System.IO.Stream)">
            <summary>
            Loads <see cref="T:Microsoft.CodeAnalysis.AssemblyPortabilityPolicy"/> information from XML with App.config schema.
            </summary>
            <exception cref="T:System.Xml.XmlException">The stream doesn't contain a well formed XML.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="input"/> is null.</exception>
            <remarks>
            Tries to find supportPortability elements in the given XML:
            <![CDATA[
            <configuration>
               <runtime>
                  <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
                     <supportPortability PKT="7cec85d7bea7798e" enable="false"/>
                     <supportPortability PKT="31bf3856ad364e35" enable="false"/>
                  </assemblyBinding>
               </runtime>
            </configuration>
            ]]>
            
            Keeps the stream open.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopAssemblyIdentityComparer.IsFrameworkAssembly(Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Returns true if the identity is a Framework 4.5 or lower assembly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DesktopStrongNameProvider">
            <summary>
            Provides strong name and signs source assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopStrongNameProvider.#ctor(System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Creates an instance of <see cref="T:Microsoft.CodeAnalysis.DesktopStrongNameProvider"/>.
            </summary>
            <param name="keyFileSearchPaths">
            An ordered set of fully qualified paths which are searched when locating a cryptographic key file.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopStrongNameProvider.ResolveStrongNameKeyFile(System.String)">
            <summary>
            Resolves assembly strong name key file path.
            Internal for testing.
            </summary>
            <returns>Normalized key file path or null if not found.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopStrongNameProvider.SignAssembly(Microsoft.CodeAnalysis.StrongNameKeys,System.IO.Stream,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopStrongNameProvider.GetPublicKey(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopStrongNameProvider.Sign(System.String,System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopStrongNameProvider.Sign(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommandLineAnalyzerReference">
            <summary>
            Describes a command line analyzer assembly specification.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineAnalyzerReference.FilePath">
            <summary>
            Assembly file path.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.EncodedStringText.s_fallbackEncoding">
            <summary>
            Encoding to use when there is no byte order mark (BOM) on the stream. This encoder may throw a <see cref="T:System.Text.DecoderFallbackException"/>
            if the stream contains invalid UTF-8 bytes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.Create(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)">
            <summary>
            Initializes an instance of <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from the provided stream. This version differs
            from <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.From(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean)"/> in two ways:
            1. It attempts to minimize allocations by trying to read the stream into a byte array.
            2. If <paramref name="defaultEncoding"/> is null, it will first try UTF8 and, if that fails, it will
               try <see cref="P:System.Text.Encoding.Default"/>.
            </summary>
            <param name="stream">The stream containing encoded text.</param>
            <param name="defaultEncoding">
            Specifies an encoding to be used if the actual encoding can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If not specified auto-detect heuristics are used to determine the encoding. If these heuristics fail the decoding is assumed to be <see cref="P:System.Text.Encoding.Default"/>.
            Note that if the stream starts with Byte Order Mark the value of <paramref name="defaultEncoding"/> is ignored.
            </param>
            <param name="checksumAlgorithm">Hash algorithm used to calculate document checksum.</param>
            <exception cref="T:System.IO.InvalidDataException">
            The stream content can't be decoded using the specified <paramref name="defaultEncoding"/>, or
            <paramref name="defaultEncoding"/> is null and the stream appears to be a binary file.
            </exception>
            <exception cref="T:System.IO.IOException">An IO error occurred while reading from the stream.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.Decode(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean)">
            <summary>
            Try to create a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from the given stream using the given encoding.
            </summary>
            <param name="data">The input stream containing the encoded text. The stream will not be closed.</param>
            <param name="encoding">The expected encoding of the stream. The actual encoding used may be different if byte order marks are detected.</param>
            <param name="checksumAlgorithm">The checksum algorithm to use.</param>
            <param name="throwIfBinaryDetected">Throw <see cref="T:System.IO.InvalidDataException"/> if binary (non-text) data is detected.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> decoded from the stream.</returns>
            <exception cref="T:System.Text.DecoderFallbackException">The decoder was unable to decode the stream with the given encoding.</exception>
            <remarks>
            internal for unit testing
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryGetByteArrayFromStream(System.IO.Stream)">
            <summary>
            Some streams are easily represented as byte arrays.
            </summary>
            <param name="data">The stream</param>
            <returns>
            The contents of <paramref name="data"/> as a byte array or null if the stream can't easily
            be read into a byte array.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryGetByteArrayFromMemoryStream(System.IO.MemoryStream,System.Byte[]@)">
            <summary>
            If the MemoryStream was created with publiclyVisible=true, then we can access its buffer
            directly and save allocations in StreamReader. The input MemoryStream is not closed on exit.
            </summary>
            <returns>True if a byte array could be created.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryGetByteArrayFromFileStream(System.IO.FileStream,System.Byte[]@)">
            <summary>
            Read the contents of a <see cref="T:System.IO.FileStream"/> into a byte array.
            </summary>
            <param name="stream">The FileStream with encoded text.</param>
            <param name="buffer">A byte array filled with the contents of the file.</param>
            <returns>True if a byte array could be created.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataCache">
             <summary>
             Manages cache of the following information for Portable Executables loaded from files.
            
             For assemblies - a map from file name and timestamp to: 
                 1) A weak reference to the corresponding PEAssembly object;
                 2) A list of weak references to instances of VB/CS AssemblySymbols based on the PEAssembly object.
            
             For modules - a map from file name and timestamp to a weak reference to the corresponding PEModule object
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataCache.s_assembliesFromFiles">
            <summary>
            Global cache for assemblies imported from files.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataCache.s_modulesFromFiles">
            <summary>
            Global cache for net-modules imported from files.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataCache.s_compactTimer">
            <summary>
            Timer triggering compact operation for metadata cache.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataCache.compactTimerPeriod">
            <summary>
            Period at which the timer is firing (30 seconds).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataCache.s_compactInProgress">
            <summary>
            compactTimer's procedure is in progress.
            Used to prevent multiple instances running in parallel.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataCache.s_compactTimerIsOn">
            <summary>
            compactTimer is on, i.e. will fire.
            
            This field is changed to 'yes' only by EnableCompactTimer(),
            and is changed to 'no' only by CompactCache().
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataCache.s_compactCollectionCount">
            <summary>
            Collection count last time the cache was compacted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataCache.Guard">
            <summary>
            Lock that must be acquired for the duration of read/write operations on MetadataCache.
            
            Internal for testing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.GetCollectionCount">
            <summary>
            Return amount of GC collections occurred so far.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.CompactCache(System.Object)">
            <summary>
            Called by compactTimer to compact the cache.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.EnableCompactTimer">
            <summary>
            Trigger timer every 30 seconds.
            Cache must be locked before calling this method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataCache.CompactTimerIsOn">
            <summary>
            For test purposes only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.TriggerCacheCompact">
            <summary>
            Trigger compact operation for the cache, meant to be used for test purpose only.
            Locking the cache prior to calling this method is a good way to get into a deadlock.
            
            For test purposes only!!!
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.CompactCacheOfAssemblies">
            <summary>
            Called by compactTimer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.CompactCacheOfModules">
            <summary>
            Called by compactTimer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataCache.AssembliesFromFiles">
            <summary>
            Global cache for assemblies imported from files.
            Internal accessibility is for test purpose only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataCache.AssemblyKeys">
            <summary>
            For test purposes only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataCache.ModulesFromFiles">
            <summary>
            Global cache for net-modules imported from files.
            Internal accessibility is for test purpose only.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataCache.ModuleKeys">
            <summary>
            For test purposes only.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataCache.CleaningCacheLock">
            <summary>
            This class is meant to be used for test purpose only.
            It locks MetadataCache until the instance is disposed.
            Upon locking, the cache is swapped with an empty cache,
            original cache is restored before the cache is unlocked.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.CleaningCacheLock.CleanCaches">
            <summary>
            Clean global metadata caches, meant to be used for test purpose only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.GetOrCreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataImageKind)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.GetOrCreateAssemblyFromFile(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataCache.GetOrCreateModuleFromFile(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataFileReference">
            <summary>
            Represents metadata stored in a file.
            </summary>
            <remarks>
            Metadata image is read from the file, owned by the reference, and doesn't change 
            since the reference is accessed by the compiler until the reference object is garbage collected.
            During this time the file is open and its content is read-only.
            
            If you need to manage the lifetime of the metadata (and the file stream) explicitly use <see cref="T:Microsoft.CodeAnalysis.MetadataImageReference"/> or 
            implement a custom subclass of <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataFileReference.GetMetadataImpl">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataFileReferenceResolver">
            <summary>
            Resolves metadata references specified in source code (#r directives).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataFileReferenceResolver.#ctor(System.Collections.Immutable.ImmutableArray{System.String},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.MetadataFileReferenceResolver"/> class.
            </summary>
            <param name="searchPaths">An ordered set of fully qualified 
            paths which are searched when resolving assembly names.</param>
            <param name="baseDirectory">Directory used when resolving relative paths.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataFileReferenceResolver.#ctor(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.MetadataFileReferenceResolver"/> class.
            </summary>
            <param name="searchPaths">An ordered set of fully qualified 
            paths which are searched when resolving assembly names.</param>
            <param name="baseDirectory">Directory used when resolving relative paths.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataFileReferenceResolver.SearchPaths">
            <summary>
            Search paths used when resolving metadata references.
            </summary>
            <remarks>
            All search paths are absolute.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataFileReferenceResolver.BaseDirectory">
            <summary>
            Directory used for resolution of relative paths.
            A full directory path or null if not available.
            </summary>
            <remarks>
            This directory is only used if the base directory isn't implied by the context within which the path is being resolved.
            
            It is used, for example, when resolving a strong name key file specified in <see cref="T:System.Reflection.AssemblyKeyFileAttribute"/>,
            or a metadata file path specified in <see cref="P:Microsoft.CodeAnalysis.PortableExecutableReference.FilePath"/>.
            
            Resolution of a relative path that needs the base directory fails if the base directory is null.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataFileReferenceResolver.ResolveReference(System.String,System.String)">
            <summary>
            Resolves a metadata reference that is a path or an assembly name.
            </summary>
            <param name="reference">Reference path.</param>
            <param name="baseFilePath">
            The base file path to use to resolve relative paths against.
            Null to use the <see cref="P:Microsoft.CodeAnalysis.MetadataFileReferenceResolver.BaseDirectory"/> as a base for relative paths.
            </param>
            <returns>
            Normalized absolute path to the referenced file or null if it can't be resolved.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SerializableCompilationOptions">
            <summary>
            Represents compilation options common to C# and VB.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SerializableParseOptions">
            <summary>
            Represents parse options common to C# and VB.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceFileResolver">
            <summary>
            Resolves references to source files specified in source code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.XmlFileResolver">
            <summary>
            Resolves references to XML files specified in the source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.XmlFileResolver.ResolveReference(System.String,System.String)">
            <summary>
            Resolves XML document file path.
            </summary>
            <param name="path">
            Value of the "file" attribute of an &lt;include&gt; documentation comment element.
            </param>
            <param name="baseFilePath">
            Path of the source file (<see cref="P:Microsoft.CodeAnalysis.SyntaxTree.FilePath"/>) or XML document that contains the <paramref name="path"/>.
            If not null used as a base path of <paramref name="path"/>, if <paramref name="path"/> is relative.
            If <paramref name="baseFilePath"/> is relative <see cref="P:Microsoft.CodeAnalysis.XmlFileResolver.BaseDirectory"/> is used as the base path of <paramref name="baseFilePath"/>.
            </param>
            <returns>Normalized XML document file path or null if not found.</returns>
        </member>
        <member name="F:Roslyn.Utilities.FileKey.FullPath">
            <summary>
            Full case-insensitive path.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.FileKey.Timestamp">
            <summary>
            Last write time (UTC).
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileKey.#ctor(System.String,System.DateTime)">
            <summary>
            Constructor.
            </summary>
            <param name="fullPath">Full path.</param>
            <param name="timestamp">Last write time (UTC).</param>
        </member>
        <member name="M:Roslyn.Utilities.FileKey.Create(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.ResolveRelativePath(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Func{System.String,System.Boolean})">
            <summary>
            Resolves relative path and returns absolute path.
            The method depends only on values of its parameters and their implementation (for fileExists).
            It doesn't itself depend on the state of the current process (namely on the current drive directories) or 
            the state of file system.
            </summary>
            <param name="path">
            Path to resolve.
            </param>
            <param name="basePath">
            Base file path to resolve CWD-relative paths against. Null if not available.
            </param>
            <param name="baseDirectory">
            Base directory to resolve CWD-relative paths against if <paramref name="basePath"/> isn't specified. 
            Must be absolute path.
            Null if not available.
            </param>
            <param name="searchPaths">
            Sequence of paths used to search for unqualified relative paths.
            </param>
            <param name="fileExists">
            Method that tests existence of a file.
            </param>
            <returns>
            The resolved path or null if the path can't be resolved.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.NormalizeAbsolutePath(System.String)">
            <summary>
            Normalizes an absolute path.
            </summary>
            <param name="path">Path to normalize.</param>
            <exception cref="T:System.IO.IOException"/>
            <returns>Normalized path.</returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.CreateFileStreamChecked(System.Func{System.String,System.IO.FileStream},System.String,System.String)">
            <summary>
            Used to create a file given a path specified by the user.
            paramName - Provided by the Public surface APIs to have a clearer message. Internal API just rethrow the exception
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.DeleteFileOnClose(System.String)">
            <summary>
            Marks given file for automatic deletion when all its handles are closed.
            Note that after doing this the file can't be opened again, not even by the same process.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetFileTimeStamp(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Empty">
            <summary>
            Null or empty.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Relative">
            <summary>
            "file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentDirectory">
            <summary>
            ".\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentParent">
            <summary>
            "..\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentRoot">
            <summary>
            "\dir\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToDriveDirectory">
            <summary>
            "C:dir\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Absolute">
            <summary>
            "C:\file" or "\\machine" (UNC).
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetDirectoryName(System.String)">
            <summary>
            Get directory name from path.
            </summary>
            <remarks>
            Unlike <see cref="M:System.IO.Path.GetDirectoryName(System.String)"/> it
                doesn't check for invalid path characters, 
                doesn't strip any trailing directory separators (TODO: tomat),
                doesn't recognize UNC structure \\computer-name\share\directory-name\file-name (TODO: tomat).
            </remarks>
            <returns>Prefix of path that represents a directory. </returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsDriveRootedAbsolutePath(System.String)">
            <summary>
            Returns true if given path is absolute and starts with a drive specification ("C:\").
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetPathRoot(System.String)">
            <summary>
            Get a prefix of given path which is the root of the path.
            </summary>
            <returns>
            Root of an absolute path or null if the path isn't absolute or has invalid format (e.g. "\\").
            It may or may not end with a directory separator (e.g. "C:\", "C:\foo", "\\machine\share", etc.) .
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetUncPathRootLength(System.String)">
            <summary>
            Calculates the length of root of an UNC path.
            </summary>
            <remarks>
            "\\server\share" is root of UNC path "\\server\share\dir1\dir2\file".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)">
            <summary>
            Combines an absolute path with a relative.
            </summary>
            <param name="root">Absolute root path.</param>
            <param name="relativePath">Relative path.</param>
            <returns>
            An absolute combined path, or null if <paramref name="relativePath"/> is 
            absolute (e.g. "C:\abc", "\\machine\share\abc"), 
            relative to the current root (e.g. "\abc"), 
            or relative to a drive directory (e.g. "C:abc\def").
            </returns>
            <seealso cref="M:Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)">
            <summary>
            Combine two paths, the first of which may be absolute.
            </summary>
            <param name="rootOpt">First path: absolute, relative, or null.</param>
            <param name="relativePath">Second path: relative and non-null.</param>
            <returns>null, if <paramref name="rootOpt"/> is null; a combined path, otherwise.</returns>
            <seealso cref="M:Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsFilePath(System.String)">
            <summary>
            Determines whether an assembly reference is considered an assembly file path or an assembly name.
            used, for example, on values of /r and #r.
            </summary>
        </member>
    </members>
</doc>
